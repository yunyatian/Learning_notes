### `JVM解释运行字节码文件，不问字节码文件的出处，即只要字节码文件符合JVM虚拟机的规范，不论字节码文件出自什么语言编译而来，JVM都可以解释运行`
### `JVM是运行在操作系统之上的，它与硬件没有直接的交互，不同的操作系统的JVM是有区别的`
### `HotSpot VM是目前市面上高性能虚拟机代表作之一，它采用的是解释器和即时编译器并存的架构`
### `JVM整体结构图如下：`![avatar](D:\下载\JVM整体结构.png)

### `由于跨平台性的设计，Java的指令都是根据栈来设计的`
### `优点：`
> * 跨平台性
> * 指令集小
> * 指令多
### `缺点：`
> * 执行性能比寄存器差
### 虚拟机的启动：
> * Java虚拟机的启动是通过引导类加载器创建一个初始类来完成的，这个类是由虚拟机的具体实现指定的
### 虚拟机的执行：
> * 程序开始执行时，虚拟机开始运行，程序结束时，虚拟机就停止
> * 执行一个所谓的Java程序时，真正执行的是一个叫做Java虚拟机的进程
### 虚拟机的退出：
> * 程序的正常执行结束
> * 程序在执行过程中遇到了异常或错误而异常终止
> * 由于操作系统出现错误而导致Java虚拟机进程终止
> * 某线程调用Running类或System类的exit方法，或Running类的halt方法，并且Java安全管理也允许这次exit或halt操作
> * 除此之外，JNI规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的与退出情况
### 三大商用虚拟机：
> * HotSpot
> * JRockit
> * J9
### `JVM内部结构详细图如下：`
![avatar](D:\下载\内部结构详细图.png)
# 类的加载过程
## 加载：
> * 通过一个类的全限定名获取定义此类的二进制字节流
> * 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
> * 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
### `补充：加载.Class文件的方式`
> * 从本地系统中直接加载
> * 通过网络获取，典型场景：Web Applet
> * 从zip压缩包中读取，成为日后jar，war格式的基础
> * 运行时计算生成，使用最多的是：动态代理技术
> * 由其他文件生成，典型场景：JSP应用
> * 从专有数据库中提取.class文件，比较少见
> * 从加密文件中获取，典型的放Class文件被反编译的保护措施
## 链接:
> 验证：
> > * 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机的自身安全
> > * 主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证
> > * JVM认证的class文件都是以CA FE BA BE开头的
######
> 准备：
> > * 为类变量分配内存并且设置该类变量的默认初始值，即零值
> > * 这里不包括用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化
> > * 这里不会为实例变量分配初始化，类变量会分配在方法区，而实例变量是会随着对象一起分配到Java堆中
######
>  解析：
> > * 将常量池内的符号引用转换为直接引用的过程
> > * 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行
> > * 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针，相对位移量或一个间接定位到目标的句柄
> > * 解析动作主要针对类或接口，字段，类方法，接口方法，方法类型等，对应常量池中的CONSTANT_Class_info，CCNSTANT_Fieldref_info,CONSTANT_Methodref_info等。
## 初始化：
> * 初始化阶段就是执行类构造器方法<clinit>的过程
> * 此方法不许定义，是java编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来
> * 构造器方法中指令按语句在源文件中出现的执行顺序
> * <clinit>()不同于类的构造器。（关联：构造器是虚拟机视角下的<init>()）
> * 若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕
> * 虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁
# 类加载器的分类
> * JVM支持两种类型的类加载器，分别为类加载器和自定义类加载器
> * JVM中的自定义加载器指的是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器
> * 一般而言是引导类加载器自成一类，而且引导类加载器使用C/C++写的，一般在Java中是获取不到bootstrapClassLoader
> * 自定义类加载器中常见的是扩展类加载器（ExtClassLoader）和系统类加载器（SystemClassLoader），相互之间的关系是包含关系，不是上下层，也不是父子类关系
### `类的加载器分类图如下`:
![avatar](D:\下载\类加载器分类.png)
# 双亲委派机制
## 工作原理：
> * 如果一个类加载器收到类加载请求，他并不会自己先去请求，而是把这个请求委托给父类的加载器去执行
> * 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器
> * 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制
## 优势：
> * 避免类的重复加载
> * 保护程序安全，防止核心API被随意篡改
